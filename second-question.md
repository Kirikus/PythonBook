Продумаем архитектуру нового проекта. 

Так как мы пишем карточную игру, то, очевидно, нам придется реализовать карты как класс. Какую функцию должен выполнять представитель такого класса и всеь класс в целом? Представитель данного класса должен однозначно и полностью определять всю информацию, которая доступна игрокам \(или правилам игры, если она сокрыта от игроков\) при изучении игровой карты. Класс же в целом должен предоставлять интерфейс для работы с карт друг с другом: сравнение между собой, изменение \(если это подразумевается правилами\) и т.п.

Далее, заметим, что карты не существуют отдельно друг от друга и игрового поля: любая карта должна находиться в колоде, на руке у одного из игроков, на игровом поле или же в иной специально предназначенной для этого зоне. Такие зоны будут называться контейнерами, и их ролью будет хранение перечня карт \(с сохранением порядка, потому что если он не важен, то его скрытое наличие не мешает работе\), а также упрощение работы по перемещинию карт из одного такого поля в другое.

Никакая карточная игра не имеет смысла без наличия игроков. Задача игроков проста: принятие различных решений по ходу игры. Дополнительно, игрок может обладать отдельными игровыми свойствами: рукой с картами, количеством очков и иными характеристиками, зависящими от конкретной игры. Заметим, что в самых простых карточных играх игроки могут не обладать одной из этой функций. К примеру, в Пьянице игроки не принимают никаких решений, а в играх на скорость реакции вроде Барабашки или Jungle Speed у игроков может не быть отдельных свойств \(если играть на выбывание до определения проигравшего игрока\).

В правилах любой карточной игры описаны фазы, которые структурируют игру. Фазы это отдельные действия или их наборы, которые совершаются друг за другом. В наиболее общем виде вся игра состоит из одной фазы, по завершении которой игра заканчивается. Другой крайностью являются действия, выполняющиеся при отыгрыше отдельной карты. Фазы служат единственным источником изменений в игре, а степень их детализации \(стоит ли выделять отдельные фазы для взятия каждой карты при пополнении руки до фиксированного количества карт\) уже остается на усмотрение разработчика.

Наконец, введем объект, описывающий текущее состояние игры, который мы будем называть одноименно - игра. На первый взгляд может показаться, что это антипаттерн програмирования "Божественный Объект" - класс, умеющий и делающий всё, однако имеется одно существенное отличие. Объявив, что классигры содержит текущее состояние, а отдельные изменения этого состояния осуществляются фазами, мы оставили данному классу одну единсвенную функцию. 

Далее можно было продолжать процесс дробления на классы, так как для отрисовки игры желательно выделять отдельные классы, чтобы сохранить возможность отрисовки объектов отдельно от самих объектов. Мы этого делать не будем из-за того, что данный проект является лишь учебным.

