Приступим к реализации первого класса - карты.

Что можно, по умолчанию, утверждать про карты? Неизвестно, будут ли масти и значения у карт, неизвестно какие поля \(данные\) будут на карте. Следовательно, никакие данные не могут быть переданы в конструктор такого класса:

```
class Card(object):
  def __init__(self):
    pass
```

Однако, можно утверждать, что карты могут быть одинаковыми или различными, вне зависимости от их конкретного вида. Следовательно, реализуем эти методы сравнения

```
  def __eq__(self, other):
    raise NotImplementedError
  def __ne__(self, other):
    return not (self == other)
```

Сравнение на неравенство реализовано через сравнение на равенство, хотя это и приводит к большим наклодным расходам при его вызове. Причиной выбора такой реализации служит его больгая надежность: при наследовании от этого класса меньше вероятность реализовать эти методы неверно.

Далее, как мы и говорили ранее, добавим в этот класс методов печати, которых, по сути, и не должно в них быть \(напомним, что предпочтительнее реализовавать отрисовку - и, в частности, печать -в отдельном объекте\). Все ради простоты учебного кода:

```
  pass  def __repr__(self):
    return "Card"
  def __str__(self):
    return "Card"
```

Наконец, будем предпологать, что все карты игры перечислимы. Это понадобится нам для составления колоды карт. Так как это свойство уже принадлежит не отдельной карте, а всем картам в целом, то реализуем его статическим методом \(т.е. методом, не принимающим аргументом конкретный экземпляр класса\):

```
@staticmethod
  def all_cards():
    raise NotImplementedError
```



